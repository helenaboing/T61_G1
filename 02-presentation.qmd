---
title: "Análise de Vendas e Clientes"
author: "Helena Boing, Alejandra Moreira, Joana Costa, Lohanna Pombo, Pedro Sequeira"
format: 
  revealjs:
    theme: default
    css: styles.css
    slide-number: true
    footer: "Análise de Vendas e Clientes"
    background-transition: fade
    transition: fade
    highlight-style: github
    code-fold: true
    code-tools: true
    code-link: true
    code-copy: true
    code-line-numbers: true
    code-highlight: true
    code-annotations: true
    code-echo: false
    code-eval: true
    code-warning: true
    code-error: true
    code-message: false
    code-output: true
    code-cache: true
    code-freeze: false
    width: 1050
    height: 700
    margin: 0.1
    center: false
    navigationMode: linear
    controlsLayout: edges
    controlsTutorial: false
    hash: true
    history: true
    hashOneBasedIndex: false
    fragmentInURL: false
    pdfSeparateFragments: false
    lang: en
    auto-stretch: true
    header-includes:
      - |
        <style>
          /* Geometric shapes in corners */
          .reveal .slides section::before {
            content: "";
            position: absolute;
            top: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(70, 130, 180, 0.2);
            border-radius: 50%;
            z-index: -1;
          }
          
          .reveal .slides section::after {
            content: "";
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            border: 2px solid rgba(70, 130, 180, 0.2);
            transform: rotate(45deg);
            z-index: -1;
          }
          
          /* Hexagon pattern in background */
          .reveal .slides section {
            background: 
              linear-gradient(60deg, rgba(70, 130, 180, 0.05) 25%, transparent 25.5%, transparent 75%, rgba(70, 130, 180, 0.05) 75%, rgba(70, 130, 180, 0.05)),
              linear-gradient(120deg, rgba(70, 130, 180, 0.05) 25%, transparent 25.5%, transparent 75%, rgba(70, 130, 180, 0.05) 75%, rgba(70, 130, 180, 0.05));
            background-size: 60px 104px;
            background-position: 0 0, 30px 52px;
          }
          
          /* Decorative lines */
          .reveal .slides section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, 
              rgba(70, 130, 180, 0.2),
              rgba(70, 130, 180, 0.1),
              rgba(70, 130, 180, 0.2));
          }
          
          /* Title slide special styling */
          .reveal .slides section:first-child::before {
            width: 150px;
            height: 150px;
            border-width: 3px;
          }
          
          .reveal .slides section:first-child::after {
            width: 120px;
            height: 120px;
            border-width: 3px;
          }
          
          /* Ensure content remains readable */
          .reveal .slides section h1,
          .reveal .slides section h2,
          .reveal .slides section h3,
          .reveal .slides section p {
            position: relative;
            z-index: 1;
          }
        </style>
execute: 
  echo: false
  eval: true
  warning: true
  error: true
  message: false
  output: true
  cache: true
  freeze: false
---

```{r setup, include=FALSE}
# Install required packages if not already installed
required_packages <- c("dplyr", "ggplot2", "lubridate", "scales", "tidyr", "knitr")
new_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)

# Load all required packages
library(dplyr)
library(ggplot2)
library(lubridate)
library(scales)    # For comma() and percent()
library(tidyr)
library(knitr)

# Load data
load("dfinal.Rda")

# Create age groups
dfinal <- dfinal %>%
  mutate(
    FaixaIdade = case_when(
      Idade <= 18 ~ "0-18",
      Idade <= 30 ~ "19-30",
      Idade <= 45 ~ "31-45",
      Idade <= 60 ~ "46-60",
      TRUE ~ "60+"
    )
  )

# Set default theme for all plots
theme_set(theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )
)
```



## Maioria dos clientes tem 31–45 anos; gêneros igualmente representados

```{r}
# Prepare data for the pyramid
pyramid_data <- dfinal %>%
  distinct(CustomerKey, Gender, FaixaIdade) %>%
  count(Gender, FaixaIdade) %>%
  mutate(
    n = ifelse(Gender == "M", -n, n),  # Make male values negative for the pyramid effect
    Gender = factor(Gender, levels = c("M", "F"), labels = c("Masculino", "Feminino")),
    FaixaIdade = factor(FaixaIdade, 
                       levels = c("0-18", "19-30", "31-45", "46-60", "60+"),
                       ordered = TRUE)
  )

# Create the pyramid plot
print(
  ggplot(pyramid_data, aes(x = FaixaIdade, y = n, fill = Gender)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("Masculino" = "#4682B4", "Feminino" = "#FF69B4")) +
    coord_flip() +
    scale_y_continuous(
      labels = function(x) abs(x),
      breaks = pretty(pyramid_data$n)
    ) +
    labs(
      title = "Pirâmide Demográfica dos Clientes",
      x = "Faixa Etária",
      y = "Número de Clientes",
      fill = "Gênero"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(hjust = 0.5, face = "bold")
    )
)
```

## Estados Unidos e Austrália concentram a maior parte das vendas
```{r}
# Análise por país
vendas_por_pais <- dfinal %>%
  group_by(CountryRegionName) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    TicketMedio = TotalVendas / NumPedidos
  ) %>%
  arrange(desc(TotalVendas))

# Gráfico de barras para vendas por país
print(
  ggplot(vendas_por_pais, aes(x = reorder(CountryRegionName, TotalVendas), y = TotalVendas)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    labs(
      title = "Total de Vendas por País",
      x = "País",
      y = "Total de Vendas (€)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## Vendas são dominadas por Califórnia e estados australianos
```{r}
# Análise por região/estado
vendas_por_regiao <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    TicketMedio = TotalVendas / NumPedidos,
    .groups = "drop"
  ) %>%
  arrange(desc(TotalVendas))

# Top 10 regiões por vendas
top_regioes <- vendas_por_regiao %>%
  slice_max(TotalVendas, n = 10)

print(
  ggplot(top_regioes, aes(x = reorder(StateProvinceName, TotalVendas), y = TotalVendas)) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    labs(
      title = "Top 10 Regiões por Volume de Vendas",
      x = "Região/Estado",
      y = "Total de Vendas (€)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## Análise Específica dos Estados Unidos
```{r}
# Análise específica para os EUA
USA_Result <- dfinal %>%
  filter(CountryRegionName == "United States")

sales_by_state <- USA_Result %>%
  group_by(StateProvinceName) %>%
  summarise(
    TotalSales = sum(SalesAmount, na.rm = TRUE),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    TicketMedio = TotalSales / NumPedidos
  ) %>%
  arrange(desc(TotalSales))

# Top 5 estados dos EUA
top5_states <- sales_by_state %>%
  slice_max(TotalSales, n = 5)

print(
  ggplot(top5_states, aes(x = reorder(StateProvinceName, TotalSales), y = TotalSales)) +
    geom_bar(stat = "identity", fill = "red") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    labs(
      title = "Top 5 Estados dos EUA por Volume de Vendas",
      x = "Estado",
      y = "Total de Vendas (€)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## Análise de Longevidade dos Clientes
```{r}
# Calcular métricas de longevidade
clientes_longevidade <- dfinal %>%
  distinct(CustomerKey, DateFirstPurchase) %>%
  mutate(
    DateFirstPurchase = as.Date(DateFirstPurchase),
    TimeasCustomer_days = as.numeric(Sys.Date() - DateFirstPurchase),
    TimeasCustomer_years = TimeasCustomer_days / 365.25,
    Old_NewCustomer = ifelse(TimeasCustomer_days > 2675.5, "Old", "New")
  )

# Análise de vendas por tipo de cliente
vendas_por_tipo_cliente <- dfinal %>%
  inner_join(clientes_longevidade %>% select(CustomerKey, Old_NewCustomer), 
             by = "CustomerKey",
             relationship = "many-to-many") %>%
  group_by(Old_NewCustomer) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    TicketMedio = TotalVendas / NumClientes
  )

print(
  ggplot(vendas_por_tipo_cliente, aes(x = Old_NewCustomer, y = TotalVendas, fill = Old_NewCustomer)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("Old" = "darkblue", "New" = "lightblue")) +
    labs(
      title = "Volume de Vendas por Tipo de Cliente",
      subtitle = "Comparação entre clientes antigos e novos",
      x = "Tipo de Cliente",
      y = "Total de Vendas (€)"
    ) +
    scale_y_continuous(labels = scales::comma) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      legend.position = "none"
    )
)
```

## Londres e Paris lideram amplamente o volume de vendas entre as cidades
```{r}
# Análise por cidade
vendas_por_cidade <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName, City) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    TicketMedio = TotalVendas / NumPedidos,
    .groups = "drop"
  ) %>%
  arrange(desc(TotalVendas))

# Top 15 cidades por vendas
top_cidades <- vendas_por_cidade %>%
  slice_max(TotalVendas, n = 15)

print(
  ggplot(top_cidades, aes(x = reorder(City, TotalVendas), y = TotalVendas)) +
    geom_bar(stat = "identity", fill = "darkred") +
    coord_flip() +
    scale_y_continuous(labels = scales::comma) +
    labs(
      title = "Top 15 Cidades por Volume de Vendas",
      x = "Cidade",
      y = "Total de Vendas (€)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## Métricas Geográficas Principais
```{r}
# Calcular métricas principais
metricas_geograficas <- list(
  "Total de Países" = n_distinct(dfinal$CountryRegionName),
  "Total de Regiões/Estados" = n_distinct(dfinal$StateProvinceName),
  "Total de Cidades" = n_distinct(dfinal$City),
  "País com Maior Volume" = vendas_por_pais$CountryRegionName[1],
  "Região com Maior Volume" = vendas_por_regiao$StateProvinceName[1],
  "Cidade com Maior Volume" = vendas_por_cidade$City[1]
)

# Exibir métricas
cat("Métricas Geográficas Principais:\n")
for (i in seq_along(metricas_geograficas)) {
  cat(names(metricas_geograficas)[i], ":", metricas_geograficas[[i]], "\n")
}
```

## Paris lidera densidade de clientes, superando amplamente outras regiões
```{r}
# Calcular densidade de clientes por região
densidade_clientes <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName) %>%
  summarise(
    NumClientes = n_distinct(CustomerKey),
    TotalVendas = sum(SalesAmount),
    NumCidades = n_distinct(City),
    DensidadeClientes = NumClientes / NumCidades,
    TicketMedio = TotalVendas / NumClientes,
    .groups = "drop"
  ) %>%
  arrange(desc(DensidadeClientes))

# Visualizar top 10 regiões por densidade de clientes
print(
  ggplot(head(densidade_clientes, 10), 
         aes(x = reorder(StateProvinceName, DensidadeClientes), 
             y = DensidadeClientes)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    labs(
      title = "Top 10 Regiões por Densidade de Clientes",
      subtitle = "Número médio de clientes por cidade",
      x = "Região",
      y = "Clientes por Cidade"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
)
```

## Bikes dominam as vendas nas principais regiões
```{r}
# Análise de preferências por categoria por região
preferencias_categoria <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName, ProductCategoryName) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    .groups = "drop"
  ) %>%
  group_by(CountryRegionName, StateProvinceName) %>%
  mutate(
    PercentualCategoria = TotalVendas / sum(TotalVendas) * 100
  ) %>%
  arrange(desc(TotalVendas))

# Visualizar top 5 regiões e suas preferências por categoria
top_regioes_categoria <- preferencias_categoria %>%
  group_by(StateProvinceName) %>%
  summarise(TotalVendas = sum(TotalVendas)) %>%
  slice_max(TotalVendas, n = 5) %>%
  pull(StateProvinceName)

print(
  ggplot(preferencias_categoria %>% 
           filter(StateProvinceName %in% top_regioes_categoria),
         aes(x = StateProvinceName, y = PercentualCategoria, fill = ProductCategoryName)) +
    geom_bar(stat = "identity", position = "stack") +
    coord_flip() +
    scale_fill_brewer(palette = "Set3") +
    labs(
      title = "Distribuição de Vendas por Categoria nas Top 5 Regiões",
      x = "Região",
      y = "Percentual de Vendas (%)",
      fill = "Categoria"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      legend.position = "bottom"
    )
)
```

## Potencial de Crescimento Regional: Identificação de Oportunidades Prioritárias
```{r}
# Identificar mercados com potencial de crescimento
oportunidades_mercado <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName) %>%
  summarise(
    NumClientes = n_distinct(CustomerKey),
    TotalVendas = sum(SalesAmount),
    NumCidades = n_distinct(City),
    TicketMedio = TotalVendas / NumClientes,
    Crescimento = as.numeric(difftime(max(OrderDate), min(OrderDate), units = "days")) / 365,  # Anos de operação
    VendasPorAno = TotalVendas / Crescimento,
    .groups = "drop"
  ) %>%
  # Remover regiões com menos de 1 ano de operação
  filter(Crescimento >= 1) %>%
  # Normalizar as variáveis
  mutate(
    NumCidadesNorm = (NumCidades - mean(NumCidades)) / sd(NumCidades),
    TicketMedioNorm = (TicketMedio - mean(TicketMedio)) / sd(TicketMedio),
    VendasPorAnoNorm = (VendasPorAno - mean(VendasPorAno)) / sd(VendasPorAno),
    # Calcular score de oportunidade
    ScoreOportunidade = (NumCidadesNorm * 0.4) +  # Peso para número de cidades
                        (TicketMedioNorm * 0.3) +  # Peso para ticket médio
                        (VendasPorAnoNorm * 0.3)   # Peso para vendas por ano
  ) %>%
  arrange(desc(ScoreOportunidade))
```

::: {.smaller}
## Metodologia e Fatores de Avaliação

- **Número de Cidades** (40% do score)
  - Indica a cobertura geográfica e capacidade de expansão local

- **Ticket Médio** (30% do score)
  - Mede o valor médio das transações e poder de compra dos clientes

- **Vendas Anuais** (30% do score)
  - Avalia o volume de negócios e trajetória de crescimento

::: {.callout-note collapse="true"}
Score de Oportunidade = (0.4 × cidades normalizado) + (0.3 × ticket médio normalizado) + (0.3 × vendas por ano normalizado)
:::
:::

```{r}
#| include: false
# Remove any global equation definitions
```

## Critérios e Oportunidades

- ✓ Mínimo de 1 ano de operação
- ✓ Dados normalizados para comparabilidade
- ✓ Agregação por região (país/estado)
- ✓ Filtro de operações recentes

- 🎯 **Regiões Líderes**: Mercados mais promissores para expansão e investimentos
- 📊 **Ranking Objetivo**: Facilita a alocação de recursos e decisões comerciais

## Califórnia e Inglaterra lideram em potencial de crescimento entre mercados analisados
```{r}
# Visualizar top 10 mercados com maior potencial
print(
  ggplot(head(oportunidades_mercado, 10),
         aes(x = reorder(StateProvinceName, ScoreOportunidade),
             y = ScoreOportunidade)) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    coord_flip() +
    labs(
      title = "Top 10 Mercados com Maior Potencial de Crescimento",
      subtitle = "Score baseado em número de cidades, ticket médio e vendas por ano",
      x = "Região",
      y = "Score de Oportunidade"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
)
```

## Detalhes das Top 5 Regiões com Maior Potencial
```{r}
# Exibir detalhes das top 5 regiões
cat("\nDetalhes das Top 5 Regiões com Maior Potencial:\n")
top_5_regioes <- head(oportunidades_mercado, 5)
for (i in 1:nrow(top_5_regioes)) {
  cat("\n", top_5_regioes$StateProvinceName[i], ":\n")
  cat("  Número de Cidades:", top_5_regioes$NumCidades[i], "\n")
  cat("  Ticket Médio: €", format(round(top_5_regioes$TicketMedio[i], 2), big.mark = ","), "\n")
  cat("  Vendas por Ano: €", format(round(top_5_regioes$VendasPorAno[i], 2), big.mark = ","), "\n")
  cat("  Score de Oportunidade:", round(top_5_regioes$ScoreOportunidade[i], 2), "\n")
}
```

## Resumo de Penetração de Mercado
```{r}
# Calcular métricas de resumo
resumo_penetracao <- list(
  "Regiões com Alta Densidade" = nrow(filter(densidade_clientes, DensidadeClientes > median(DensidadeClientes))),
  "Regiões com Baixa Densidade" = nrow(filter(densidade_clientes, DensidadeClientes <= median(DensidadeClientes))),
  "Categoria Mais Popular" = names(sort(table(dfinal$ProductCategoryName), decreasing = TRUE)[1]),
  "Região com Maior Crescimento" = head(oportunidades_mercado, 1)$StateProvinceName,
  "Ticket Médio Global" = mean(dfinal$SalesAmount / dfinal$OrderQuantity),
  "Número Médio de Cidades por Região" = mean(densidade_clientes$NumCidades)
)

# Exibir resumo
cat("Resumo de Penetração de Mercado:\n")
for (i in seq_along(resumo_penetracao)) {
  cat(names(resumo_penetracao)[i], ":", resumo_penetracao[[i]], "\n")
}
```

## Análise de Preço vs. Demanda por Produto

```{r}
# Preparar dados para o gráfico de bolhas
produto_analise <- dfinal %>%
  group_by(ProductKey, ProductName, ProductCategoryName) %>%
  summarise(
    PrecoMedio = mean(UnitPrice),
    QuantidadeTotal = sum(OrderQuantity),
    VendasTotais = sum(SalesAmount),
    NumPedidos = n_distinct(SalesOrderNumber),
    .groups = "drop"
  ) %>%
  # Remover outliers extremos para melhor visualização
  filter(
    PrecoMedio <= quantile(PrecoMedio, 0.95),
    QuantidadeTotal <= quantile(QuantidadeTotal, 0.95)
  )

# Criar o gráfico de bolhas
  ggplot(produto_analise, 
         aes(x = PrecoMedio, 
             y = QuantidadeTotal,
             size = VendasTotais,
             color = ProductCategoryName)) +
    geom_point(alpha = 0.6) +
    scale_size_continuous(
      name = "Vendas Totais (€)",
      labels = scales::comma,
      range = c(3, 15)
    ) +
    scale_color_brewer(
      name = "Categoria",
      palette = "Set1"
    ) +
    scale_x_continuous(
      name = "Preço Médio Unitário (€)",
      labels = scales::comma
    ) +
    scale_y_continuous(
      name = "Quantidade Total Vendida",
      labels = scales::comma
    ) +
    labs(
      title = "Relação entre Preço, Demanda e Vendas por Produto",
      subtitle = "Tamanho da bolha representa o valor total de vendas"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      legend.position = "right",
      legend.box = "vertical"
    )
```

## Métricas Resumidas por Categoria de Produto
```{r}
# Exibir métricas resumidas por categoria
cat("\nMétricas por Categoria de Produto:\n")

# Preparar dados para análise
produto_analise <- dfinal %>%
  group_by(ProductKey, ProductName, ProductCategoryName) %>%
  summarise(
    PrecoMedio = mean(UnitPrice),
    QuantidadeTotal = sum(OrderQuantity),
    VendasTotais = sum(SalesAmount),
    NumPedidos = n_distinct(SalesOrderNumber),
    .groups = "drop"
  ) %>%
  # Remover outliers extremos para melhor visualização
  filter(
    PrecoMedio <= quantile(PrecoMedio, 0.95),
    QuantidadeTotal <= quantile(QuantidadeTotal, 0.95)
  )

# Exibir métricas resumidas
produto_analise %>%
  group_by(ProductCategoryName) %>%
  summarise(
    PrecoMedio = mean(PrecoMedio),
    QuantidadeMedia = mean(QuantidadeTotal),
    VendasTotais = sum(VendasTotais),
    NumProdutos = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(VendasTotais)) %>%
  mutate(
    PrecoMedio = round(PrecoMedio, 2),
    QuantidadeMedia = round(QuantidadeMedia, 0),
    VendasTotais = round(VendasTotais, 2)
  ) %>%
  knitr::kable(
    col.names = c("Categoria", "Preço Médio (€)", "Qtd. Média", "Vendas Totais (€)", "Nº Produtos"),
    format = "simple"
  )
```

## Distribuição Geográfica das Vendas

```{r}
# Preparar dados para o mapa
vendas_por_cidade <- dfinal %>%
  group_by(City, StateProvinceName, CountryRegionName) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumClientes = n_distinct(CustomerKey),
    NumPedidos = n_distinct(SalesOrderNumber),
    .groups = "drop"
  ) %>%
  # Remover cidades com vendas muito baixas para melhor visualização
  filter(TotalVendas > quantile(TotalVendas, 0.1))

# Criar o mapa base
mapa_base <- ggplot() +
  borders("world", colour = "gray85", fill = "gray95") +
  theme_void()

# Adicionar as bolhas de vendas
mapa_vendas <- mapa_base +
  geom_point(
    data = vendas_por_cidade,
    aes(x = as.numeric(factor(StateProvinceName)), 
        y = as.numeric(factor(CountryRegionName)),
        size = TotalVendas,
        color = NumClientes),
    alpha = 0.6
  ) +
  scale_size_continuous(
    name = "Total de Vendas (€)",
    labels = scales::comma,
    range = c(3, 15)
  ) +
  scale_color_gradient(
    name = "Número de Clientes",
    low = "blue",
    high = "red"
  ) +
  labs(
    title = "Distribuição Geográfica das Vendas",
    subtitle = "Tamanho da bolha representa o volume de vendas, cor representa o número de clientes"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "right",
    legend.box = "vertical"
  )

# Exibir o mapa
print(mapa_vendas)
```

::: {.smaller}
## Top 10 Cidades por Volume de Vendas
```{r}
# Exibir métricas das top 10 cidades
cat("\nTop 10 Cidades por Volume de Vendas:\n")
vendas_por_cidade %>%
  arrange(desc(TotalVendas)) %>%
  head(10) %>%
  select(City, StateProvinceName, CountryRegionName, TotalVendas, NumClientes) %>%
  mutate(
    TotalVendas = round(TotalVendas, 2),
    TotalVendas = scales::comma(TotalVendas)
  ) %>%
  knitr::kable(
    col.names = c("Cidade", "Estado/Província", "País", "Total de Vendas (€)", "Nº de Clientes"),
    format = "simple"
  )
```

:::

## Vendas aceleram fortemente a partir de Q2 2018
```{r}
vendas_trimestrais <- dfinal %>%
  mutate(
    Ano = year(OrderDate),
    TrimestreNum = quarter(OrderDate),
    DataTrimestre = make_date(Ano, (TrimestreNum - 1) * 3 + 1, 1),
    Trimestre = paste0("Q", TrimestreNum, " ", Ano)
  ) %>%
  # Filter out Q3 2019 before summarization
  filter(!(Ano == 2019 & TrimestreNum == 3)) %>%
  group_by(Trimestre, DataTrimestre) %>%
  summarise(TotalVendas = sum(SalesAmount, na.rm = TRUE), .groups = "drop") %>%
  arrange(DataTrimestre) %>%
  mutate(Trimestre = factor(Trimestre, levels = unique(Trimestre)))

# Calculate metrics
primeiro_trimestre <- min(vendas_trimestrais$DataTrimestre)
ultimo_trimestre <- max(vendas_trimestrais$DataTrimestre)
primeiro_valor <- vendas_trimestrais$TotalVendas[1]
ultimo_valor <- tail(vendas_trimestrais$TotalVendas, 1)
anos_totais <- as.numeric(difftime(ultimo_trimestre, primeiro_trimestre, units = "days")) / 365.25

# Calculate CAGR
cagr <- (ultimo_valor/primeiro_valor)^(1/anos_totais) - 1

# Calculate YoY growth for each year
crescimento_anual <- vendas_trimestrais %>%
  mutate(Ano = year(DataTrimestre)) %>%
  group_by(Ano) %>%
  summarise(VendasAno = sum(TotalVendas)) %>%
  arrange(Ano) %>%
  mutate(
    CrescimentoYoY = (VendasAno/lag(VendasAno) - 1) * 100
  )

# Calculate average quarterly growth
crescimento_trimestral <- vendas_trimestrais %>%
  mutate(
    CrescimentoTrimestral = (TotalVendas/lag(TotalVendas) - 1) * 100
  ) %>%
  summarise(
    MediaCrescimentoTrimestral = mean(CrescimentoTrimestral, na.rm = TRUE)
  )

# Create the plot with annotations
print(
  ggplot(vendas_trimestrais, aes(x = Trimestre, y = TotalVendas, group = 1)) +
    geom_line(color = "blue", linewidth = 1) +
    geom_point(color = "darkblue") +
    geom_smooth(method = "loess", formula = y ~ x, se = FALSE, color = "red", linetype = "dashed") +
    # Add annotations for metrics
    annotate("text", 
             x = Inf, y = -Inf,
             label = paste0(
               "CAGR: ", scales::percent(cagr, accuracy = 0.1), "\n",
               "Cresc. Médio Trimestral: ", scales::percent(crescimento_trimestral$MediaCrescimentoTrimestral/100, accuracy = 0.1), "\n",
               "Cresc. Anual 2018: ", scales::percent(crescimento_anual$CrescimentoYoY[2]/100, accuracy = 0.1), "\n",
               "Cresc. Anual 2019: ", scales::percent(crescimento_anual$CrescimentoYoY[3]/100, accuracy = 0.1)
             ),
             hjust = 1.1, vjust = -0.5,
             linewidth = 3.5,
             family = "sans") +
    labs(
      title = "Volume de Vendas por Trimestre",
      x = "Trimestre",
      y = "Total de Vendas"
    ) +
    scale_y_continuous(labels = scales::comma) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```


## Vendas uniformemente distribuídas ao longo da semana
```{r}
# Set locale to English
vendas_por_dia <- dfinal %>%
  mutate(
    Weekday = wday(OrderDate, label = TRUE, abbr = FALSE),
    Weekday = factor(Weekday, 
      levels = c("Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"),
      ordered = TRUE)
  ) %>%
  group_by(Weekday) %>%
  summarise(
    TotalSales = sum(SalesAmount, na.rm = TRUE),
    NumOrders = n(),
    .groups = "drop"
  ) %>%
  mutate(
    AverageSales = TotalSales / NumOrders,
    Percentage = TotalSales / sum(TotalSales) * 100
  )

# Create a more informative visualization
print(
  ggplot(vendas_por_dia, aes(x = Weekday, y = TotalSales)) +
    geom_col(fill = "steelblue", alpha = 0.8) +
    geom_text(aes(label = paste0("€", format(round(TotalSales), big.mark = ","))), 
              vjust = -0.5, size = 3.5) +
    geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
              vjust = 2, size = 3.5, color = "white") +
    labs(
      title = "Distribuição de Vendas por Dia da Semana",
      subtitle = "Valor total e percentual de vendas",
      x = "Dia da Semana",
      y = "Total de Vendas (€)"
    ) +
    scale_y_continuous(labels = scales::comma) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
)
```

## Visão Geral do Negócio

- Total de vendas: `r scales::comma(sum(dfinal$SalesAmount))` €
- Número de clientes únicos: `r dplyr::n_distinct(dfinal$CustomerKey)`
- Número de produtos vendidos: `r dplyr::n_distinct(dfinal$ProductKey)`
- Período analisado: `r format(min(dfinal$OrderDate), '%d/%m/%Y')` a `r format(max(dfinal$OrderDate), '%d/%m/%Y')`

## ATV em queda desde ago/2017

```{r}
# Calculate ATV by month
atv_mensal <- dfinal %>%
  group_by(Ano = year(OrderDate), Mes = month(OrderDate)) %>%
  summarise(
    TotalVendas = sum(SalesAmount),
    NumTransacoes = n_distinct(SalesOrderNumber),
    ATV = TotalVendas / NumTransacoes,
    .groups = "drop"
  ) %>%
  mutate(
    Data = make_date(Ano, Mes, 1),
    MesAno = format(Data, "%b/%Y")
  ) %>%
  # Remove the last month as it's incomplete
  filter(Data < max(Data))

# Create ATV trend plot
print(
  ggplot(atv_mensal, aes(x = Data, y = ATV)) +
    geom_line(color = "blue", linewidth = 1) +
    geom_point(color = "darkblue") +
    geom_smooth(method = "loess", formula = y ~ x, se = FALSE, color = "red", linetype = "dashed") +
    labs(
      title = "Evolução do Valor Médio de Transação (ATV)",
      subtitle = "Tendência mensal do valor médio por transação",
      x = "Mês",
      y = "ATV (€)"
    ) +
    scale_y_continuous(labels = scales::comma) +
    scale_x_date(date_labels = "%b/%Y", date_breaks = "3 months") +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
)

# Calculate and display overall ATV (excluding last month)
atv_geral <- sum(atv_mensal$TotalVendas) / sum(atv_mensal$NumTransacoes)
cat("\nATV (Valor médio por transação) Geral: €", format(round(atv_geral, 2), big.mark = ","))
```

## Top 10 Produtos Mais Vendidos
```{r}
top10 <- dfinal %>%
  group_by(ProductKey, ProductName) %>%
  summarise(TotalQuantity = sum(OrderQuantity, na.rm = TRUE), .groups = "drop") %>%
  slice_max(TotalQuantity, n = 10) %>%
  arrange(TotalQuantity)

print(
  ggplot(top10, aes(x = reorder(ProductName, TotalQuantity), y = TotalQuantity)) +
    geom_col(fill = "darkgreen") +
    coord_flip() +
    labs(
      title = "Top 10 Produtos Mais Vendidos",
      x = "Produto",
      y = "Quantidade Vendida"
    ) +
    theme_minimal() +
    theme(
      text = element_text(size = 14),
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## A maioria dos lucros são gerados pela categoria de produtos "Bike"

```{r}
print(
  dfinal %>%
    group_by(ProductCategoryName) %>%
    summarise(LucroTotal = sum(Lucro, na.rm = TRUE)) %>%
    arrange(desc(LucroTotal)) %>%
    ggplot(aes(x = reorder(ProductCategoryName, LucroTotal), y = LucroTotal)) +
      geom_bar(stat = "identity", fill = "steelblue") +
      coord_flip() +
      labs(
        title = "Lucro Total por Categoria de Produto",
        x = "Categoria",
        y = "Lucro Total"
      ) +
      scale_y_continuous(labels = scales::comma) +
      theme_minimal()
)
```

## Comportamento de Compra

### Taxa de Recompra
```{r, include=FALSE}
clientes_multiplas_compras <- dfinal %>%
  dplyr::group_by(CustomerKey) %>%
  dplyr::summarise(NumCompras = dplyr::n_distinct(SalesOrderNumber)) %>%
  dplyr::filter(NumCompras >= 2) %>%
  nrow()

taxa_recompra <- round(
  clientes_multiplas_compras / dplyr::n_distinct(dfinal$CustomerKey) * 100, 1
)
media_tempo_compras <- dfinal %>%
  dplyr::group_by(CustomerKey) %>%
  dplyr::filter(n() >= 2) %>%
  dplyr::summarise(
    PrimeiraCompra = min(OrderDate),
    UltimaCompra = max(OrderDate),
    NumCompras = n()
  ) %>%
  dplyr::mutate(
    DiasEntreCompras = as.numeric(difftime(UltimaCompra, PrimeiraCompra, units = "days")),
    TempoMedio = DiasEntreCompras / (NumCompras - 1)
  ) %>%
  dplyr::summarise(TempoMedioGlobal = mean(TempoMedio, na.rm = TRUE)) %>%
  dplyr::pull(TempoMedioGlobal) %>%
  round(1)
```

- Clientes com múltiplas compras: `r clientes_multiplas_compras`
- Taxa de recompra: `r taxa_recompra`%
- Tempo médio entre compras: `r media_tempo_compras` dias

```{r}
# Preparar dados de coorte
library(dplyr)
library(lubridate)

# 1. Identificar a primeira compra de cada cliente
primeiras_compras <- dfinal %>%
  group_by(CustomerKey) %>%
  summarise(PrimeiraCompra = min(OrderDate), .groups = "drop")

# 2. Juntar com os dados originais e calcular o mês relativo
cohort_data <- dfinal %>%
  inner_join(primeiras_compras, by = "CustomerKey") %>%
  mutate(
    CohortMonth = format(floor_date(PrimeiraCompra, "month"), "%Y-%m"),
    MesRelativo = (year(OrderDate) - year(PrimeiraCompra)) * 12 +
                  (month(OrderDate) - month(PrimeiraCompra))
  )

# 3. Para cada cliente, coorte e mês, contar o número de compras
compras_por_mes <- cohort_data %>%
  group_by(CohortMonth, CustomerKey, MesRelativo) %>%
  summarise(NumCompras = n(), .groups = "drop")

# 4. Para mês 0, contar apenas clientes com NumCompras > 1
#    Para meses > 0, contar clientes com NumCompras > 0
compras_por_mes <- compras_por_mes %>%
  mutate(
    Recompra = case_when(
      MesRelativo == 0 ~ NumCompras > 1,
      MesRelativo > 0 ~ NumCompras > 0,
      TRUE ~ FALSE
    )
  )

# 5. Calcular o tamanho da coorte
cohort_sizes <- cohort_data %>%
  filter(MesRelativo == 0) %>%
  group_by(CohortMonth) %>%
  summarise(CohortSize = n_distinct(CustomerKey), .groups = "drop")

# 6. Calcular a taxa de retenção
cohort_retention <- compras_por_mes %>%
  filter(Recompra) %>%
  group_by(CohortMonth, MesRelativo) %>%
  summarise(ClientesRetidos = n_distinct(CustomerKey), .groups = "drop") %>%
  left_join(cohort_sizes, by = "CohortMonth") %>%
  mutate(Retencao = ClientesRetidos / CohortSize)

#| title: "Análise de Retenção por Cohorte"
#| echo: false

anos <- unique(year(as.Date(paste0(cohort_retention$CohortMonth, "-01"))))

```{r}
#| results: 'asis'
for (ano in anos) {
  cat("## Retenção de Clientes -", ano, "\n\n")
  dados_ano <- cohort_retention %>% filter(year(as.Date(paste0(CohortMonth, "-01"))) == ano)
  print(
    ggplot(dados_ano, aes(x = MesRelativo, y = CohortMonth, fill = Retencao)) +
      geom_tile(color = "white", linewidth = 0.5) +
      scale_fill_gradient2(
        low = "#f7fbff", 
        mid = "#6baed6", 
        high = "#08306b", 
        midpoint = 0.5, 
        labels = scales::percent_format(accuracy = 1),
        name = "Taxa de Retenção"
      ) +
      geom_text(
        aes(label = ifelse(!is.na(Retencao) & Retencao > 0, 
                          scales::percent(Retencao, accuracy = 1), "")), 
        size = 3.5, 
        color = "black",
        fontface = "bold"
      ) +
      scale_x_continuous(
        breaks = 0:50, 
        labels = paste0(0:50, ""),
        name = "Meses desde a Primeira Compra (meses)"
      ) +
      labs(
        title = paste("Análise de Retenção de Clientes -", ano),
        subtitle = "Percentual de clientes que realizaram compras em cada mês após a primeira compra",
        x = "Meses desde a Primeira Compra (meses)",
        y = "Mês de Primeira Compra (Ano-Mês)",
        fill = "Taxa de Retenção"
      ) +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10),
        axis.text.y = element_text(size = 10),
        plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 11, margin = margin(b = 20)),
        legend.title = element_text(size = 11),
        legend.text = element_text(size = 10),
        panel.grid.major = element_line(color = "gray90"),
        panel.grid.minor = element_blank()
      )
  )
  cat("\n\n")
}
```

## Margens por Categoria de Produto
```{r}
# Calcular métricas de rentabilidade por categoria
margens_categoria <- dfinal %>%
  group_by(ProductCategoryName) %>%
  summarise(
    VendasTotais = sum(SalesAmount),
    CustoTotal = sum(StandardCost),
    TaxasTotais = sum(TaxAmt),
    FreteTotal = sum(Freight),
    LucroBruto = VendasTotais - CustoTotal,
    MargemBruta = (LucroBruto / VendasTotais) * 100,
    MargemLiquida = ((LucroBruto - TaxasTotais - FreteTotal) / VendasTotais) * 100,
    .groups = "drop"
  ) %>%
  arrange(desc(MargemLiquida))

# Visualizar margens por categoria
print(
  ggplot(margens_categoria, aes(x = reorder(ProductCategoryName, MargemLiquida))) +
    geom_bar(aes(y = MargemLiquida), stat = "identity", fill = "steelblue", alpha = 0.7) +
    geom_text(aes(y = MargemLiquida, label = paste0(round(MargemLiquida, 1), "%")),
              vjust = -0.5, size = 3.5) +
    labs(
      title = "Margem Líquida por Categoria de Produto",
      subtitle = "Percentual de lucro após custos diretos, taxas e frete",
      x = "Categoria",
      y = "Margem Líquida (%)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
)
```

## Análise de Custos Operacionais
```{r}
# Calcular métricas de custos operacionais
custos_operacionais <- dfinal %>%
  group_by(ProductCategoryName) %>%
  summarise(
    VendasTotais = sum(SalesAmount),
    FreteTotal = sum(Freight),
    TaxasTotais = sum(TaxAmt),
    FretePorVenda = FreteTotal / VendasTotais * 100,
    TaxasPorVenda = TaxasTotais / VendasTotais * 100,
    .groups = "drop"
  ) %>%
  pivot_longer(
    cols = c(FretePorVenda, TaxasPorVenda),
    names_to = "TipoCusto",
    values_to = "Percentual"
  ) %>%
  mutate(
    TipoCusto = factor(TipoCusto,
      levels = c("FretePorVenda", "TaxasPorVenda"),
      labels = c("Frete", "Taxas")
    )
  )

# Visualizar custos operacionais
print(
  ggplot(custos_operacionais, 
         aes(x = reorder(ProductCategoryName, Percentual), 
             y = Percentual, 
             fill = TipoCusto)) +
    geom_bar(stat = "identity", position = "dodge") +
    scale_fill_brewer(palette = "Set2") +
    labs(
      title = "Custos Operacionais por Categoria",
      subtitle = "Percentual de frete e taxas sobre vendas",
      x = "Categoria",
      y = "Percentual sobre Vendas (%)",
      fill = "Tipo de Custo"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "bottom"
    )
)
```

## Eficiência Operacional por Região
```{r}
# Calcular métricas de eficiência por região
eficiencia_regional <- dfinal %>%
  group_by(CountryRegionName, StateProvinceName) %>%
  summarise(
    VendasTotais = sum(SalesAmount),
    FreteTotal = sum(Freight),
    TaxasTotais = sum(TaxAmt),
    NumPedidos = n_distinct(SalesOrderNumber),
    FretePorPedido = FreteTotal / NumPedidos,
    TaxasPorPedido = TaxasTotais / NumPedidos,
    .groups = "drop"
  ) %>%
  # Filtrar regiões com volume significativo
  filter(VendasTotais > quantile(VendasTotais, 0.1)) %>%
  # Calcular score de eficiência (inverso dos custos)
  mutate(
    ScoreEficiencia = 1 / ((FretePorPedido + TaxasPorPedido) / VendasTotais)
  ) %>%
  arrange(desc(ScoreEficiencia))

# Visualizar top 15 regiões por eficiência
print(
  ggplot(head(eficiencia_regional, 15),
         aes(x = reorder(StateProvinceName, ScoreEficiencia),
             y = ScoreEficiencia)) +
    geom_bar(stat = "identity", fill = "darkgreen", alpha = 0.7) +
    coord_flip() +
    labs(
      title = "Top 15 Regiões por Eficiência Operacional",
      subtitle = "Score baseado em custos de frete e taxas por pedido",
      x = "Região",
      y = "Score de Eficiência"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
)
```

## Resumo de Rentabilidade e Eficiência
```{r}
# Calcular métricas resumidas
resumo_rentabilidade <- list(
  "Margem Bruta Média" = mean(margens_categoria$MargemBruta),
  "Margem Líquida Média" = mean(margens_categoria$MargemLiquida),
  "Custo de Frete Médio" = mean(custos_operacionais$Percentual[custos_operacionais$TipoCusto == "Frete"]),
  "Custo de Taxas Médio" = mean(custos_operacionais$Percentual[custos_operacionais$TipoCusto == "Taxas"]),
  "Categoria Mais Rentável" = margens_categoria$ProductCategoryName[1],
  "Categoria Menos Rentável" = margens_categoria$ProductCategoryName[nrow(margens_categoria)],
  "Região Mais Eficiente" = eficiencia_regional$StateProvinceName[1]
)

# Exibir resumo
cat("Resumo de Rentabilidade e Eficiência:\n")
for (i in seq_along(resumo_rentabilidade)) {
  if (grepl("Média", names(resumo_rentabilidade)[i])) {
    cat(names(resumo_rentabilidade)[i], ":", 
        round(resumo_rentabilidade[[i]], 1), "%\n")
  } else {
    cat(names(resumo_rentabilidade)[i], ":", 
        resumo_rentabilidade[[i]], "\n")
  }
}
```

## Análise de Rentabilidade por Categoria e Subcategoria

```{r}
# Calcular rentabilidade por categoria
profit_by_category <- dfinal %>%
  group_by(ProductCategoryName) %>%
  summarise(
    MargemMedia = mean((SalesAmount - StandardCost) / SalesAmount * 100, na.rm = TRUE),
    LucroTotal = sum(SalesAmount - StandardCost, na.rm = TRUE)
  ) %>%
  arrange(desc(MargemMedia))

# Visualizar margens por categoria
print(
  ggplot(profit_by_category, aes(x = reorder(ProductCategoryName, MargemMedia), y = MargemMedia)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    labs(
      title = "Margem Média por Categoria de Produto",
      x = "Categoria",
      y = "Margem Média (%)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5)
    )
)
```

## Crescimento de Vendas por Subcategoria

```{r}
# Calcular crescimento por subcategoria
growth_by_subcategory <- dfinal %>%
  mutate(Ano = year(OrderDate)) %>%
  group_by(ProductSubcategoryName, Ano) %>%
  summarise(
    QuantidadeTotal = sum(OrderQuantity),
    ReceitaTotal = sum(SalesAmount),
    LucroTotal = sum(SalesAmount - StandardCost),
    .groups = "drop"
  ) %>%
  group_by(ProductSubcategoryName) %>%
  mutate(
    CrescimentoQuantidade = (QuantidadeTotal - lag(QuantidadeTotal)) / lag(QuantidadeTotal) * 100,
    CrescimentoReceita = (ReceitaTotal - lag(ReceitaTotal)) / lag(ReceitaTotal) * 100,
    CrescimentoLucro = (LucroTotal - lag(LucroTotal)) / lag(LucroTotal) * 100
  ) %>%
  filter(!is.na(CrescimentoReceita))

# Visualizar top 5 subcategorias por crescimento de receita
print(
  growth_by_subcategory %>%
    filter(Ano == max(Ano)) %>%
    slice_max(CrescimentoReceita, n = 5) %>%
    ggplot(aes(x = reorder(ProductSubcategoryName, CrescimentoReceita), 
               y = CrescimentoReceita)) +
    geom_col(fill = "#4CAF50") +
    coord_flip() +
    labs(
      title = "Top 5 Subcategorias por Crescimento de Receita",
      subtitle = paste("Ano:", max(growth_by_subcategory$Ano)),
      x = "Subcategoria",
      y = "Crescimento de Receita (%)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
)
```

## Análise de Crescimento Detalhada

```{r}
# Calcular métricas de crescimento
crescimento_metrics <- growth_by_subcategory %>%
  filter(Ano == max(Ano)) %>%
  summarise(
    SubcategoriasCrescimento = sum(CrescimentoReceita > 0),
    SubcategoriasDeclinio = sum(CrescimentoReceita < 0),
    CrescimentoMedio = mean(CrescimentoReceita),
    CrescimentoMaximo = max(CrescimentoReceita),
    CrescimentoMinimo = min(CrescimentoReceita)
  )

# Exibir métricas
cat("Métricas de Crescimento:\n")
cat("Subcategorias em Crescimento:", crescimento_metrics$SubcategoriasCrescimento, "\n")
cat("Subcategorias em Declínio:", crescimento_metrics$SubcategoriasDeclinio, "\n")
cat("Crescimento Médio:", round(crescimento_metrics$CrescimentoMedio, 1), "%\n")
cat("Crescimento Máximo:", round(crescimento_metrics$CrescimentoMaximo, 1), "%\n")
cat("Crescimento Mínimo:", round(crescimento_metrics$CrescimentoMinimo, 1), "%\n")
```

## Top 10 Produtos por Crescimento de Lucro

```{r}
# Calcular crescimento por produto
growth_by_product <- dfinal %>%
  mutate(Ano = year(OrderDate)) %>%
  group_by(ProductKey, ProductName, Ano) %>%
  summarise(
    QuantidadeTotal = sum(OrderQuantity),
    ReceitaTotal = sum(SalesAmount),
    LucroTotal = sum(SalesAmount - StandardCost),
    .groups = "drop"
  ) %>%
  group_by(ProductKey) %>%
  mutate(
    CrescimentoLucro = (LucroTotal - lag(LucroTotal)) / lag(LucroTotal) * 100
  ) %>%
  filter(!is.na(CrescimentoLucro))

# Visualizar top 10 produtos por crescimento de lucro
print(
  growth_by_product %>%
    filter(Ano == max(Ano)) %>%
    slice_max(CrescimentoLucro, n = 10) %>%
    ggplot(aes(x = reorder(ProductName, CrescimentoLucro), 
               y = CrescimentoLucro)) +
    geom_col(fill = "darkgreen") +
    coord_flip() +
    labs(
      title = "Top 10 Produtos por Crescimento de Lucro",
      subtitle = paste("Ano:", max(growth_by_product$Ano)),
      x = "Produto",
      y = "Crescimento de Lucro (%)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.y = element_text(size = 8)
    )
)
```

## Proporção de Clientes com e sem Filhos
```{r}
customers <- dfinal %>%
  mutate(TemFilhos = ifelse(NumberChildrenAtHome > 0, "Com filhos", "Sem filhos"))

# Calcular percentuais

dados_pizza <- customers %>%
  count(TemFilhos) %>%
  mutate(Percentual = round(n / sum(n) * 100, 1),
         Label = paste0(TemFilhos, ": ", Percentual, "%"))

# Criar o gráfico

ggplot(dados_pizza, aes(x = "", y = n, fill = TemFilhos)) +
  geom_col(width = 1, color = "white") +
  coord_polar("y") +
  geom_text(aes(label = Label), position = position_stack(vjust = 0.5), color = "white", size = 5) +
  labs(title = "Proporção de Clientes com e sem Filhos") +
  theme_void() +
  theme(legend.position = "none")
```

## Distribuição Salarial por Ocupação

```{r}
# Criar boxplot de salários por ocupação
print(
  ggplot(dfinal, aes(x = reorder(Occupation, YearlyIncome, FUN = median), 
                     y = YearlyIncome)) +
    geom_boxplot(fill = "steelblue", alpha = 0.7) +
    coord_flip() +  # Inverter eixos para melhor legibilidade
    labs(
      title = "Distribuição Salarial por Ocupação",
      subtitle = "Boxplot mostrando mediana, quartis e outliers",
      x = "Ocupação",
      y = "Salário Anual (€)"
    ) +
    scale_y_continuous(labels = scales::comma) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.y = element_text(size = 10)
    )
)
```

## Estatísticas Salariais das Top 5 Ocupações

```{r}
# Calcular estatísticas resumidas por ocupação
estatisticas_salario <- dfinal %>%
  group_by(Occupation) %>%
  summarise(
    Mediana = median(YearlyIncome),
    Media = mean(YearlyIncome),
    Min = min(YearlyIncome),
    Max = max(YearlyIncome),
    Q1 = quantile(YearlyIncome, 0.25),
    Q3 = quantile(YearlyIncome, 0.75),
    NumClientes = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(Mediana))

# Exibir estatísticas das top 5 ocupações
print(
  head(estatisticas_salario, 5) %>%
    mutate(
      Mediana = round(Mediana, 2),
      Media = round(Media, 2),
      Min = round(Min, 2),
      Max = round(Max, 2),
      Q1 = round(Q1, 2),
      Q3 = round(Q3, 2)
    ) %>%
    knitr::kable(
      col.names = c("Ocupação", "Mediana", "Média", "Mínimo", "Máximo", "Q1", "Q3", "Nº Clientes"),
      format = "simple"
    )
)
```


